{"ast":null,"code":"var _jsxFileName = \"/home/xacket/Projects/engresume/src/pages/learn/utils.js\";\nimport React from \"react\";\nimport store from \"../../reducers/store\";\nimport { updateUserDBObject, getUidFromNick } from \"../../firebase/database\";\nimport { Link } from \"react-router-dom\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport const MAX_ANSWERS = 8; //The number of times you answer a question before you \"learn\" it\nexport const MIN_ANSWERS = 2; //The number of times you answer a question before you level up\nexport const MAX_TRIES = 3; //Number of times you answer before it decides you don't know it\nexport const QUESTIONS_PER_LEVEL = 3;\nexport const MAX_LEARN_WORDS_PER_DAY = 5;\nexport function isAQuestion() {\n  return Number.isInteger(store.getState().questionIndex);\n}\nexport function getCurrentQuestion() {\n  return store.getState().questions[store.getState().questionIndex];\n}\n\n/**\n * Checks if two ms represented timestamps were on the same day\n * @param {string | number} ms1\n * @param {string | number} ms2\n */\nexport function isDifferentDate(ms1, ms2) {\n  ms1 = Number.parseInt(`${ms1}`);\n  ms2 = Number.parseInt(`${ms2}`);\n  if (ms1 === 0 || ms2 === 0) {\n    return true;\n  }\n  return !(new Date(ms1).toString().substr(4, 11) === new Date(ms2).toString().substr(4, 11));\n}\nexport function getPlaceholderAnswer() {\n  return isAQuestion() ? getCurrentQuestion().answeredCount === 0 ? `Type: ${getCurrentQuestion().answer}` //Show them the answer since they're learning\n  : \"Answer\" : \"Congrats!\";\n}\nexport function getQuestionAnswer() {\n  return isAQuestion() ? getCurrentQuestion().answer : \"There is no answer, since there is no question!\";\n}\nexport function isLessonInputCorrect() {\n  let input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : store.getState().lessonInput;\n  let answer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getQuestionAnswer();\n  answer = `${answer}`.replace(/( )*$/, \"\"); // Remove any trailing spaces on the answer...\n  return new RegExp(`^${answer}( )*$`).test(input);\n}\nexport function saveLearnInDB() {\n  function writeLearnToDB(songpath) {\n    const answeredCount = getCurrentQuestion().answeredCount + 1; //Db write takes time, so make sure we get the original\n    updateUserDBObject(`${songpath}/answers/${getCurrentQuestion().id}`, {\n      answeredCount,\n      answeredTime: Date.now()\n    });\n    const learnedToday = {\n      wordsLearnedToday: store.getState().lessonNewWordsLearnedToday,\n      whenTodayWas: store.getState().lessonLastSessionStartTime\n    };\n    updateUserDBObject(`learning/learnedToday/`, {\n      ...learnedToday\n    });\n  }\n  if (!store.getState().user.nick) {\n    return;\n  }\n  if (!store.getState().lessonAuthor) {\n    writeLearnToDB(`learning/songs/official/${store.getState().lessonLessonName}`);\n  } else {\n    getUidFromNick(store.getState().lessonAuthor, uid => {\n      writeLearnToDB(`learning/songs/unofficial/${uid}/${store.getState().lessonLessonName}`);\n    });\n  }\n}\nexport const spacedRepTimesInSec = [0, 0, 30 * 60, 2 * 3600, 6 * 3600, 24 * 3600, 72 * 3600, 240 * 3600];\nexport function getTimeUntilNextQuestion() {\n  let min = 9999999;\n  const now = Date.now();\n  store.getState().questions.forEach(q => {\n    if (q.answeredCount > 0) {\n      //You don't have to wait for new words\n      if (spacedRepTimesInSec[q.answeredCount] - (now - q.answeredTime) / 1000 < min) {\n        min = spacedRepTimesInSec[q.answeredCount] - (now - q.answeredTime) / 1000;\n      }\n    }\n  });\n  return min < 0 ? 0 : min;\n}\nfunction isNotPreviousQuestion(id) {\n  return store.getState().questionIndex !== id;\n}\nfunction isLessThanMaxAnswers(answeredCount) {\n  return answeredCount <= MAX_ANSWERS;\n}\nfunction questionWithinSpacedRep(question) {\n  if (!question.answeredTime) {\n    return true; //They've never answered before\n  }\n\n  const secsSince = Math.floor((Date.now() - question.answeredTime) / 1000);\n  if (secsSince >= spacedRepTimesInSec[question.answeredCount]) {\n    return true;\n  }\n  return false;\n}\nfunction newQsOnlyIfNotMaxLearned(answeredCount) {\n  return !(answeredCount === 0 && store.getState().lessonNewWordsLearnedToday >= MAX_LEARN_WORDS_PER_DAY &&\n  //At max words/day\n  !isDifferentDate(Date.now(), store.getState().lessonLastSessionStartTime)\n  //Same day\n  );\n}\n\n/**\n * Get list of questions\n * Filter out previous question\n * Filter out all questions >= MAX_ANSWERS\n * Filter out questions that aren't ready for spaced rep\n * Filter out questions with 0 answers if you've learned > MAX_WORDS_PER_DAY words today\n *\n * If there's a question answered 1 time, give a 50% chance of returning it\n * Select a random question in list\n * If it's an unseen question, reselect the first unseen question in the list\n * Return the selected question\n */\nexport function getNewQuestion() {\n  const candidateQuestions = store.getState().questions.filter(question => isNotPreviousQuestion(question.id) && isLessThanMaxAnswers(question.answeredCount) && questionWithinSpacedRep(question) && newQsOnlyIfNotMaxLearned(question.answeredCount));\n  if (candidateQuestions.length === 0) {\n    return null;\n  }\n  let indexInCandidate = null;\n\n  // If there's a question answered 1 time, give a 50% chance of returning it\n  candidateQuestions.forEach((q, index) => {\n    if (q.answeredCount === 1 && Math.random() > 0.5) {\n      indexInCandidate = index;\n    }\n  });\n  indexInCandidate = indexInCandidate ? indexInCandidate : Math.floor(Math.random() * candidateQuestions.length);\n\n  // If it's an unseen question, reselect the first unseen question in the list\n  if (candidateQuestions[indexInCandidate].answeredCount === 0) {\n    for (let i = 0; i < candidateQuestions.length; i++) {\n      if (candidateQuestions[i].answeredCount === 0) {\n        indexInCandidate = i;\n        break;\n      }\n    }\n  }\n\n  //Match the indexInCandidate to the index in the unfiltered question list\n  for (const q of store.getState().questions) {\n    if (q.answer === candidateQuestions[indexInCandidate].answer) {\n      return q.id;\n    }\n  }\n}\nexport function getLevel() {\n  const learnedQuestions = store.getState().questions.filter(question => question.answeredCount >= MIN_ANSWERS);\n  return Math.floor(learnedQuestions.length / QUESTIONS_PER_LEVEL) + 1;\n}\nexport function containsRom(string) {\n  return /[A-z]/.test(string);\n}\nexport function getError() {\n  let input = store.getState().lessonInput;\n  if (!input || input.length === 0) {\n    store.dispatch({\n      type: \"LESSON_UPDATE_ERROR\",\n      error: \"An answer is required!\"\n    });\n  } else if (containsRom(input)) {\n    store.dispatch({\n      type: \"LESSON_UPDATE_ERROR\",\n      error: \"KEYBOARD\"\n    });\n  } else if (!isLessonInputCorrect()) {\n    if (store.getState().lessonNumberOfTimesWrong >= MAX_TRIES) {\n      store.dispatch({\n        type: \"LESSON_UPDATE_REVIEW\",\n        review: true\n      });\n    } else {\n      store.dispatch({\n        type: \"LESSON_UPDATE_ERROR\",\n        error: \"Not quite - Delete it and try again!\"\n      });\n      store.dispatch({\n        type: \"LESSON_INC_NUM_TIMES_WRONG\"\n      });\n    }\n  }\n}\nexport function displayError(error) {\n  if (error === \"KEYBOARD\") {\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [\"Use a Korean keyboard! \", /*#__PURE__*/_jsxDEV(Link, {\n        to: \"/help/keyboard\",\n        children: \"How?\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 255,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true);\n  }\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: error\n  }, void 0, false);\n}\nexport function submitAnswer() {\n  if (store.getState().lessonReview) {\n    if (isLessonInputCorrect()) {\n      store.dispatch({\n        type: \"LESSON_ANSWER_QUESTION\",\n        answer: store.getState().lessonInput,\n        time: Date.now()\n      });\n    }\n    store.dispatch({\n      type: \"LESSON_UPDATE_REVIEW\",\n      review: false\n    });\n    store.dispatch({\n      type: \"LESSON_UPDATE_INPUT\",\n      input: \"\"\n    });\n    store.dispatch({\n      type: \"LESSON_RESET_NUM_TIMES_WRONG\"\n    });\n    store.dispatch({\n      type: \"LESSON_CONTINUE_BTN_TXT\",\n      text: \"Submit\"\n    });\n    store.dispatch({\n      type: \"LESSON_CHANGE_QUESTION_INDEX\",\n      id: getNewQuestion()\n    });\n    store.dispatch({\n      type: \"LESSON_UPDATE_ERROR\",\n      error: \"\"\n    });\n  } else {\n    getError();\n    if (isLessonInputCorrect() || store.getState().numberOfTimesWrong >= MAX_TRIES) {\n      store.dispatch({\n        type: \"LESSON_UPDATE_REVIEW\",\n        review: true\n      });\n    }\n    if (isLessonInputCorrect() && getCurrentQuestion()) {\n      if (getCurrentQuestion().answeredCount === 0) {\n        store.dispatch({\n          type: \"LESSON_INC_NEW_WORDS_LEARNED_TODAY\"\n        });\n      }\n      saveLearnInDB();\n    }\n  }\n}","map":{"version":3,"names":["React","store","updateUserDBObject","getUidFromNick","Link","jsxDEV","_jsxDEV","Fragment","_Fragment","MAX_ANSWERS","MIN_ANSWERS","MAX_TRIES","QUESTIONS_PER_LEVEL","MAX_LEARN_WORDS_PER_DAY","isAQuestion","Number","isInteger","getState","questionIndex","getCurrentQuestion","questions","isDifferentDate","ms1","ms2","parseInt","Date","toString","substr","getPlaceholderAnswer","answeredCount","answer","getQuestionAnswer","isLessonInputCorrect","input","arguments","length","undefined","lessonInput","replace","RegExp","test","saveLearnInDB","writeLearnToDB","songpath","id","answeredTime","now","learnedToday","wordsLearnedToday","lessonNewWordsLearnedToday","whenTodayWas","lessonLastSessionStartTime","user","nick","lessonAuthor","lessonLessonName","uid","spacedRepTimesInSec","getTimeUntilNextQuestion","min","forEach","q","isNotPreviousQuestion","isLessThanMaxAnswers","questionWithinSpacedRep","question","secsSince","Math","floor","newQsOnlyIfNotMaxLearned","getNewQuestion","candidateQuestions","filter","indexInCandidate","index","random","i","getLevel","learnedQuestions","containsRom","string","getError","dispatch","type","error","lessonNumberOfTimesWrong","review","displayError","children","to","fileName","_jsxFileName","lineNumber","columnNumber","submitAnswer","lessonReview","time","text","numberOfTimesWrong"],"sources":["/home/xacket/Projects/engresume/src/pages/learn/utils.js"],"sourcesContent":["import React from \"react\";\nimport store from \"../../reducers/store\";\nimport { updateUserDBObject, getUidFromNick } from \"../../firebase/database\";\nimport { Link } from \"react-router-dom\";\n\nexport const MAX_ANSWERS = 8; //The number of times you answer a question before you \"learn\" it\nexport const MIN_ANSWERS = 2; //The number of times you answer a question before you level up\nexport const MAX_TRIES = 3; //Number of times you answer before it decides you don't know it\nexport const QUESTIONS_PER_LEVEL = 3;\nexport const MAX_LEARN_WORDS_PER_DAY = 5;\n\nexport function isAQuestion() {\n  return Number.isInteger(store.getState().questionIndex);\n}\n\nexport function getCurrentQuestion() {\n  return store.getState().questions[store.getState().questionIndex];\n}\n\n/**\n * Checks if two ms represented timestamps were on the same day\n * @param {string | number} ms1\n * @param {string | number} ms2\n */\nexport function isDifferentDate(ms1, ms2) {\n  ms1 = Number.parseInt(`${ms1}`);\n  ms2 = Number.parseInt(`${ms2}`);\n  if (ms1 === 0 || ms2 === 0) {\n    return true;\n  }\n\n  return !(\n    new Date(ms1).toString().substr(4, 11) ===\n    new Date(ms2).toString().substr(4, 11)\n  );\n}\n\nexport function getPlaceholderAnswer() {\n  return isAQuestion()\n    ? getCurrentQuestion().answeredCount === 0\n      ? `Type: ${getCurrentQuestion().answer}` //Show them the answer since they're learning\n      : \"Answer\"\n    : \"Congrats!\";\n}\n\nexport function getQuestionAnswer() {\n  return isAQuestion()\n    ? getCurrentQuestion().answer\n    : \"There is no answer, since there is no question!\";\n}\n\nexport function isLessonInputCorrect(\n  input = store.getState().lessonInput,\n  answer = getQuestionAnswer()\n) {\n  answer = `${answer}`.replace(/( )*$/, \"\"); // Remove any trailing spaces on the answer...\n  return new RegExp(`^${answer}( )*$`).test(input);\n}\n\nexport function saveLearnInDB() {\n  function writeLearnToDB(songpath) {\n    const answeredCount = getCurrentQuestion().answeredCount + 1; //Db write takes time, so make sure we get the original\n    updateUserDBObject(`${songpath}/answers/${getCurrentQuestion().id}`, {\n      answeredCount,\n      answeredTime: Date.now(),\n    });\n\n    const learnedToday = {\n      wordsLearnedToday: store.getState().lessonNewWordsLearnedToday,\n      whenTodayWas: store.getState().lessonLastSessionStartTime,\n    };\n    updateUserDBObject(`learning/learnedToday/`, {\n      ...learnedToday,\n    });\n  }\n\n  if (!store.getState().user.nick) {\n    return;\n  }\n\n  if (!store.getState().lessonAuthor) {\n    writeLearnToDB(\n      `learning/songs/official/${store.getState().lessonLessonName}`\n    );\n  } else {\n    getUidFromNick(store.getState().lessonAuthor, (uid) => {\n      writeLearnToDB(\n        `learning/songs/unofficial/${uid}/${store.getState().lessonLessonName}`\n      );\n    });\n  }\n}\n\nexport const spacedRepTimesInSec = [\n  0,\n  0,\n  30 * 60,\n  2 * 3600,\n  6 * 3600,\n  24 * 3600,\n  72 * 3600,\n  240 * 3600,\n];\n\nexport function getTimeUntilNextQuestion() {\n  let min = 9999999;\n  const now = Date.now();\n\n  store.getState().questions.forEach((q) => {\n    if (q.answeredCount > 0) {\n      //You don't have to wait for new words\n      if (\n        spacedRepTimesInSec[q.answeredCount] - (now - q.answeredTime) / 1000 <\n        min\n      ) {\n        min =\n          spacedRepTimesInSec[q.answeredCount] - (now - q.answeredTime) / 1000;\n      }\n    }\n  });\n\n  return min < 0 ? 0 : min;\n}\n\nfunction isNotPreviousQuestion(id) {\n  return store.getState().questionIndex !== id;\n}\nfunction isLessThanMaxAnswers(answeredCount) {\n  return answeredCount <= MAX_ANSWERS;\n}\nfunction questionWithinSpacedRep(question) {\n  if (!question.answeredTime) {\n    return true; //They've never answered before\n  }\n\n  const secsSince = Math.floor((Date.now() - question.answeredTime) / 1000);\n\n  if (secsSince >= spacedRepTimesInSec[question.answeredCount]) {\n    return true;\n  }\n\n  return false;\n}\nfunction newQsOnlyIfNotMaxLearned(answeredCount) {\n  return !(\n    (\n      answeredCount === 0 &&\n      store.getState().lessonNewWordsLearnedToday >= MAX_LEARN_WORDS_PER_DAY && //At max words/day\n      !isDifferentDate(Date.now(), store.getState().lessonLastSessionStartTime)\n    ) //Same day\n  );\n}\n\n/**\n * Get list of questions\n * Filter out previous question\n * Filter out all questions >= MAX_ANSWERS\n * Filter out questions that aren't ready for spaced rep\n * Filter out questions with 0 answers if you've learned > MAX_WORDS_PER_DAY words today\n *\n * If there's a question answered 1 time, give a 50% chance of returning it\n * Select a random question in list\n * If it's an unseen question, reselect the first unseen question in the list\n * Return the selected question\n */\nexport function getNewQuestion() {\n  const candidateQuestions = store\n    .getState()\n    .questions.filter(\n      (question) =>\n        isNotPreviousQuestion(question.id) &&\n        isLessThanMaxAnswers(question.answeredCount) &&\n        questionWithinSpacedRep(question) &&\n        newQsOnlyIfNotMaxLearned(question.answeredCount)\n    );\n\n  if (candidateQuestions.length === 0) {\n    return null;\n  }\n\n  let indexInCandidate = null;\n\n  // If there's a question answered 1 time, give a 50% chance of returning it\n  candidateQuestions.forEach((q, index) => {\n    if (q.answeredCount === 1 && Math.random() > 0.5) {\n      indexInCandidate = index;\n    }\n  });\n\n  indexInCandidate = indexInCandidate\n    ? indexInCandidate\n    : Math.floor(Math.random() * candidateQuestions.length);\n\n  // If it's an unseen question, reselect the first unseen question in the list\n  if (candidateQuestions[indexInCandidate].answeredCount === 0) {\n    for (let i = 0; i < candidateQuestions.length; i++) {\n      if (candidateQuestions[i].answeredCount === 0) {\n        indexInCandidate = i;\n        break;\n      }\n    }\n  }\n\n  //Match the indexInCandidate to the index in the unfiltered question list\n  for (const q of store.getState().questions) {\n    if (q.answer === candidateQuestions[indexInCandidate].answer) {\n      return q.id;\n    }\n  }\n}\n\nexport function getLevel() {\n  const learnedQuestions = store\n    .getState()\n    .questions.filter((question) => question.answeredCount >= MIN_ANSWERS);\n\n  return Math.floor(learnedQuestions.length / QUESTIONS_PER_LEVEL) + 1;\n}\n\nexport function containsRom(string) {\n  return /[A-z]/.test(string);\n}\n\nexport function getError() {\n  let input = store.getState().lessonInput;\n\n  if (!input || input.length === 0) {\n    store.dispatch({\n      type: \"LESSON_UPDATE_ERROR\",\n      error: \"An answer is required!\",\n    });\n  } else if (containsRom(input)) {\n    store.dispatch({\n      type: \"LESSON_UPDATE_ERROR\",\n      error: \"KEYBOARD\",\n    });\n  } else if (!isLessonInputCorrect()) {\n    if (store.getState().lessonNumberOfTimesWrong >= MAX_TRIES) {\n      store.dispatch({ type: \"LESSON_UPDATE_REVIEW\", review: true });\n    } else {\n      store.dispatch({\n        type: \"LESSON_UPDATE_ERROR\",\n        error: \"Not quite - Delete it and try again!\",\n      });\n      store.dispatch({ type: \"LESSON_INC_NUM_TIMES_WRONG\" });\n    }\n  }\n}\n\nexport function displayError(error) {\n  if (error === \"KEYBOARD\") {\n    return (\n      <>\n        {\"Use a Korean keyboard! \"}\n        <Link to=\"/help/keyboard\">How?</Link>\n      </>\n    );\n  }\n\n  return <>{error}</>;\n}\n\nexport function submitAnswer() {\n  if (store.getState().lessonReview) {\n    if (isLessonInputCorrect()) {\n      store.dispatch({\n        type: \"LESSON_ANSWER_QUESTION\",\n        answer: store.getState().lessonInput,\n        time: Date.now(),\n      });\n    }\n    store.dispatch({ type: \"LESSON_UPDATE_REVIEW\", review: false });\n    store.dispatch({ type: \"LESSON_UPDATE_INPUT\", input: \"\" });\n    store.dispatch({ type: \"LESSON_RESET_NUM_TIMES_WRONG\" });\n    store.dispatch({ type: \"LESSON_CONTINUE_BTN_TXT\", text: \"Submit\" });\n    store.dispatch({\n      type: \"LESSON_CHANGE_QUESTION_INDEX\",\n      id: getNewQuestion(),\n    });\n    store.dispatch({ type: \"LESSON_UPDATE_ERROR\", error: \"\" });\n  } else {\n    getError();\n\n    if (\n      isLessonInputCorrect() ||\n      store.getState().numberOfTimesWrong >= MAX_TRIES\n    ) {\n      store.dispatch({ type: \"LESSON_UPDATE_REVIEW\", review: true });\n    }\n    if (isLessonInputCorrect() && getCurrentQuestion()) {\n      if (getCurrentQuestion().answeredCount === 0) {\n        store.dispatch({ type: \"LESSON_INC_NEW_WORDS_LEARNED_TODAY\" });\n      }\n      saveLearnInDB();\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}